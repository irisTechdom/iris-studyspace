# 计算机中的二进制表示

## 二进制
### 数字系统

* 非位置化数字系统:罗马数字
* 位置化数字系统：二进制|八进制|十进制|十六进制

1. 二进制
* 满二进位，1 + 1 = 10 = 2^1 + 0;位置依次是0位、2位、4位、8位、16位……
* 0和1
2. 八进制
* 满八进位，位置依次是0位、8位、64位……
* 0、1、2、3、4、5、6、7
3. 十进制
* 满十进位，位置依次是个位、十位、百位、千位、万位……
* 0、1、2、3、4、5、6、7、8、9
4. 十六进制
* 满十六进位
* 0、1、2、3、4、5、6、7、8、9、A、B、C、D、E
5. 二进制与bit、byte
* 一个二进制数字位叫一个bit，8个bit为1个byte，16个bit为1个字，32个bit为一个双字，64个bit为一个四字，通常我们采用字节来描述数据的大小

## 原码
* 在Java中无论整数还是小数都要带有**符号**，所以首位就作为符号位，1是负、0是正；也就是**原码包括符号位+真值**；一个字节所表示的范围
```
11111111~01111111
即
-（1*2^6+1*2^5+1*2^4+1*2^3+1*2^2+1*2^1+1*2^0) ~ 1*2^6+1*2^5+1*2^4+1*2^3+1*2^2+1*2^1+1*2^0
即-127 ~ 127

```

## 反码
* 为了便于计算机计算，引入反码；其中**正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反**
```
+1 = [0000 0001]原 = [0000 0001]反
-1 = [1000 0001]原 = [1111 1110]反
```
* 可见如果一个反码表示的是负数，人脑无法直观地看出它的数值，通常要转换为原码计算
## 补码
* 用反码计算，结果的真值部分是正确的，唯一bug是出现+0和-0两个编码；于是引入补码，不仅修复了0的符号和两个编码的问题，还能多表示一个最低数-128
* **正数的补码是其本身，负数的补码是在其原码的基础上，符号位不变，其余各个位取反，最后+1（即在反码的基础上+1）**
```
一个字节（8bit）表示的范围:
原码和反码[-127,127]
补码[-128,127]
```
# 基本数据类型

* byte
  * 占8个bit即1个字节，范围[-128,127]
* short
  * 占16个bit即2个字节，范围[-32768,32767]
* int
  * 占32个bit即4个字节，范围[-2147483648，2147483647]，最常用的类型
* long
  *占64个bit即8个字节，范围[-9223372036854775808，9223372036854775807]

* float
  * 单精度浮点型，32bit即4个字节
* double
  *双精度浮点型，64bit即8个字节
* char
  * 占16个bit即2个字节，不带符号，范围[0,65535]
* boolean

# 数据类型转换

* 隐式数据类型转换：小→大 byte → short/char → int → long→ float → double


# 补充

* 八进制

* 十六进制



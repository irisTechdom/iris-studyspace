# 封装



## 类的封装

 * 封装：把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口

 * 方式：编写类时一般将成员变量私有化，外部类需要使用Getter和Setter方法来查看和设置变量（**构造方法仍为``public``权限，否则创建不了对象**；**除非**需要通过我们的**内部的方式来构造对象，如单例模式**）

   ```java
   public class Test {
       private static Test instance;//一个私有的属性
       
       private Test(){}//一个私有的空参构造器
       
       public static Test getInstance() {//一个公有的getter方法
           if(instance == null) 
               instance = new Test();
           return instance;
       }
   }
   ```

    * 单例模式就是全局只能使用这一个对象，不能创建更多的对象

* 封装思想就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现，封装就是通过访问权限控制来实现的



# 继承和多态



## 类的继承

* 继承：在定义不同类的时候存在一些相同属性，为了**方便使用**可以将这些共同属性抽象成一个**父类**，在定义其他子类时可以继承自该父类，**减少重复代码的定义**，子类可以使用父类中**非私有**的成员

* 方式：我们可以创建各种各样的子类，想要继承一个类，只需要使用`extends`关键字继承指定父类

  * 当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为`private`，那么子类将无法访问（但是依然是继承了这个属性的）
  * 父类中定义的方法同样会被子类继承，创建一个子类对象时就可以直接使用这些方法

* 注意：

  * 类的继承可以不断向下，但是同时只能继承一个类**单继承**；同时，标记为`final`的类不允许被继承

  * 如果父类存在一个有参构造方法，子类必须在构造方法中调用，使用关键词``super``代表父类，父类的构造方法就是``super(参数列表)``

    ```java
    public class Worker extends Person{
        public Worker(String name, int age, String sex) {
            super(name, age, sex, "工人");    //父类构造调用必须在最前面
            System.out.println("工人构造成功！");    //注意，在调用父类构造方法之前，不允许执行任何代码，只能在之后执行
        }
    }
    ```

  * 使用子类时可以当作父类来用,**使用父类类型变量去引用子类对象**

    ```java
    public static void main(String[] args) {
        Person person = new Student("小明", 18, "男");    //这里使用父类类型的变量，去引用一个子类对象（向上转型）
        person.hello();    //父类对象的引用相当于当做父类来使用，只能访问父类对象的内容
    }
    ```

  * 也可以进行强制类型转换，这种方式只适用于这个对象本身就是对应的子类才可以（父类变量不存在其他子类对象引用）

    ```java
    public static void main(String[] args) {
        Person person = new Student("小明", 18, "男");
        Student student = (Student) person;   //使用强制类型转换（向下转型）
        student.study();
    }
    ```

  * 可以使用关键字``instanceof``来判断某个变量引用的对象是什么类,如果变量所引用的对象是对应类型或是对应类型的子类，那么`instanceof`都会返回`true`，否则返回`false`

    ```java
    public static void main(String[] args) {
        Person person = new Student("小明", 18, "男");
        if(person instanceof Student) {   //我们可以使用instanceof关键字来对类型进行判断
            System.out.println("对象是 Student 类型的");
        }
        if(person instanceof Person) {
            System.out.println("对象是 Person 类型的");
        }
    }
    ```

  * 子类可以和父类定义同名属性，使用时调用的是作用域最近的值；如果子类想使用父类里的同名属性，可以使用关键字``super``,``super.属性名``来表示父类的同名变量

    

## 顶层父类Object类

  * 所有类都默认继承自Object类,即所有类都包含Object类中的方法

    ```java
    public class Object {
    
        private static native void registerNatives();   //标记为native的方法是本地方法，底层是由C++实现的这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍
    
        //获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到
        public final native Class<?> getClass();
    
        //获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址
        public native int hashCode();
    
      	//判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象
      	public boolean equals(Object obj) {
            return (this == obj);
        }
      
        //克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性
        protected native Object clone() throws CloneNotSupportedException;
    
        //将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值
        public String toString() {
            return getClass().getName() + "@" + Integer.toHexString(hashCode());
        }
    
        //唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到
        public final native void notify();
    
        //唤醒所有等待当前对象锁的线程，同上
        public final native void notifyAll();
    
        //使得持有当前对象锁的线程进入等待状态，同上
        public final native void wait(long timeout) throws InterruptedException;
    
        //同上
        public final void wait(long timeout, int nanos) throws InterruptedException {
            ...
        }
    
        //同上
        public final void wait() throws InterruptedException {
            ...
        }
    
        //当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到
        protected void finalize() throws Throwable { }
    }
    ```



## 方法的重写

  * 重写：指子类定义了一个与其父类中具有相同名称、参数列表和返回类型的方法，并且子类方法的实现覆盖了父类方法的实现; **即外壳不变，核心重写**

  * 重写与重载：方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现

  * 重写Object类里的equals方法

    ```java
    public class Person{
        ...
    
        @Override   //重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略
        public boolean equals(Object obj) {   //重写方法要求与父类的定义完全一致
            if(obj == null) return false;   //如果传入的对象为null，那肯定不相等
            if(obj instanceof Person) {     //只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么
                Person person = (Person) obj;   //先转换为当前类型，接着我们对三个属性挨个进行比较
                return this.name.equals(person.name) &&    //字符串内容的比较，不能使用==，必须使用equals方法
                        this.age == person.age &&       //基本类型的比较跟之前一样，直接==
                        this.sex.equals(person.sex);
            }
            return false;
        }
    }
    ```

  * 为了方便查看属性，重写toString方法

    ```java
    @Override
    public String toString() {    //使用IDEA可以快速生成
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", sex='" + sex + '\'' +
                ", profession='" + profession + '\'' +
                '}';
    }
    ```

  * 静态方法不支持重写，因为它是属于类本身的，但是它可以被继承


### 多态
 * 多态：基于方法可以重写的特性，对于一个类定义的行为，不同的子类可以出现不同的行为就是面向对象编程中多态特性的一种体现

 * 如果不希望子类重写某个方法，我们可以在方法前添加`final`关键字，表示这个方法已经是最终形态

   

## 抽象类

* 通过添加关键字``abstract``，表示这个类是一个抽象类，抽象类中可以具有抽象方法（这个方法由关键字``abstract``修饰，且该方法只有定义，没有方法体，具体的实现，需要由子类来完成
* 抽象类的子类，必须要实现抽象类中所有抽象方法
* 因为抽象方法一定要由子类实现，其权限必须为public
* 抽象类无法直接通过new关键字来直接创建对象，要使用抽象类，只能去创建它的子类对象



## 接口

* 使用关键字``interface``表示这是一个接口

* 接口中只能定义访问权限为``public``抽象方法，其中``public``和``abstract``关键字可以省略

* 一个类通过关键字``implements``实现接口，并且可以同时实现多个,多个接口的实现使用逗号隔开

* 接口跟抽象类一样，不能直接创建对象，但是可以将接口实现类的对象以接口的形式去使用；当做接口使用时，只有接口中定义的方法和Object类的方法，无法使用类本身的方法和父类的方法

* 接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法

  * 接口中定义的静态变量只能是``public static final``的
  * 接口中定义的静态方法也只能是``public``的
  * 可以直接通过``接口名.``的方式使用静态内容

* Object类中提供的克隆方法

  ```java
  public class Student extends Person implements Study, Cloneable {   //首先实现Cloneable接口，表示这个类具有克隆的功能
      public Student(String name, int age, String sex) {
          super(name, age, sex, "学生");
      }
  
      @Override
      public Object clone() throws CloneNotSupportedException {   //提升clone方法的访问权限
          return super.clone();   //因为底层是C++实现，我们直接调用父类的实现就可以了
      }
  
      @Override
      public void study() {
          System.out.println("我会学习！");
      }
  }
  ```

   * 对象的克隆

     ```java
     public static void main(String[] args) throws CloneNotSupportedException {  //这里向上抛出一下异常，还没学异常，所以说照着写就行了
         Student student = new Student("小明", 18, "男");
         Student clone = (Student) student.clone();   //调用clone方法，得到一个克隆的对象
         System.out.println(student);
         System.out.println(clone);
         System.out.println(student == clone);
     }
     ```



## 枚举类

* 使用关键字``enum``表示这是一个枚举类

* 枚举类型的本质就是一个普通的类，但是它继承自`Enum`类，我们定义的每一个状态其实就是一个`public static final`的Status类型成员变量

  ```java
  public enum Status {
      RUNNING("睡觉"), STUDY("学习"), SLEEP("睡觉");   //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法）
  
      private final String name;    //枚举的成员变量
      Status(String name){    //覆盖原有构造方法（默认private，只能内部使用！）
          this.name = name;
      }
  
      public String getName() {   //获取封装的成员变量
          return name;
      }
  }
  ```

  

